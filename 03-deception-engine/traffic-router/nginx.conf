# traffic-router/nginx.conf
# OpenResty NGINX configuration — sole entry point for all external traffic.
# Delegates attack detection to traffic-analyzer, routes known attackers to
# decoy services via lua_shared_dict populated by Redis subscriber + internal API.

worker_processes 1;
error_log /dev/stderr warn;
pid /tmp/nginx.pid;

events {
    worker_connections 256;
}

http {
    lua_shared_dict attacker_routes 1m;
    lua_shared_dict rate_limit     2m;

    # Cluster DNS — replaced at container start by entrypoint.sh
    resolver __RESOLVER__ valid=10s ipv6=off;

    # ---------------------------------------------------------------
    # JSON access log (all requests — legitimate and attack)
    # ---------------------------------------------------------------
    log_format json_log escape=json
        '{'
            '"timestamp":"$time_iso8601",'
            '"remote_addr":"$remote_addr",'
            '"method":"$request_method",'
            '"uri":"$request_uri",'
            '"status":$status,'
            '"bytes_sent":$body_bytes_sent,'
            '"user_agent":"$http_user_agent",'
            '"x_forwarded_for":"$http_x_forwarded_for",'
            '"x_attacker_ip":"$http_x_attacker_ip",'
            '"referer":"$http_referer",'
            '"request_time":$request_time,'
            '"upstream_addr":"$upstream_addr",'
            '"upstream_status":"$upstream_status",'
            '"routed_to":"$routed_to"'
        '}';

    access_log /dev/stdout json_log;

    client_max_body_size    1m;
    client_body_buffer_size 16k;

    # ---------------------------------------------------------------
    # Background Redis subscriber — routing_update channel
    # Runs on worker 0 only, auto-reconnects on failure.
    # ---------------------------------------------------------------
    init_worker_by_lua_block {
        local function subscribe_routing_updates(premature)
            if premature then
                return
            end

            local redis_lib = require "resty.redis"
            local cjson     = require "cjson.safe"
            local routes    = ngx.shared.attacker_routes

            local red = redis_lib:new()
            red:set_timeouts(3000, 5000, 5000)

            local ok, err = red:connect("redis.monitoring.svc.cluster.local", 6379)
            if not ok then
                ngx.log(ngx.WARN, "[redis-sub] connect failed: ", err, " — retry in 5s")
                ngx.timer.at(5, subscribe_routing_updates)
                return
            end

            local res, err = red:subscribe("routing_update")
            if not res then
                ngx.log(ngx.WARN, "[redis-sub] subscribe failed: ", err, " — retry in 5s")
                pcall(function() red:close() end)
                ngx.timer.at(5, subscribe_routing_updates)
                return
            end

            ngx.log(ngx.INFO, "[redis-sub] listening on routing_update channel")

            while true do
                red:set_timeout(30000)
                local msg, read_err = red:read_reply()
                if not msg then
                    if read_err ~= "timeout" then
                        ngx.log(ngx.WARN, "[redis-sub] read error: ", read_err, " — reconnecting")
                        pcall(function() red:close() end)
                        ngx.timer.at(2, subscribe_routing_updates)
                        return
                    end
                    -- timeout is normal — loop and keep waiting
                else
                    -- msg = {"message", "routing_update", <json_payload>}
                    if type(msg) == "table" and msg[1] == "message" then
                        local ok_dec, data = pcall(cjson.decode, msg[3])
                        if ok_dec and data then
                            if data.type == "add_route" and data.attacker_ip and data.frontend_service then
                                routes:set(data.attacker_ip, data.frontend_service)
                                ngx.log(ngx.INFO, "[redis-sub] route added: ",
                                    data.attacker_ip, " -> ", data.frontend_service)

                            elseif data.type == "remove_route" then
                                if data.attacker_ip then
                                    routes:delete(data.attacker_ip)
                                    ngx.log(ngx.INFO, "[redis-sub] route removed: ", data.attacker_ip)
                                elseif data.attack_id then
                                    local keys = routes:get_keys(1024)
                                    for _, key in ipairs(keys) do
                                        local val = routes:get(key)
                                        if val and string.find(val, data.attack_id, 1, true) then
                                            routes:delete(key)
                                            ngx.log(ngx.INFO, "[redis-sub] route removed: ",
                                                key, " (attack_id=", data.attack_id, ")")
                                        end
                                    end
                                end
                            end
                        else
                            ngx.log(ngx.WARN, "[redis-sub] bad JSON payload: ", msg[3])
                        end
                    end
                end
            end
        end

        -- Only start subscriber on worker 0 to avoid duplicates
        if ngx.worker.id() == 0 then
            ngx.timer.at(1, subscribe_routing_updates)
            ngx.log(ngx.INFO, "[init] Redis subscriber scheduled on worker 0")
        end
    }

    server {
        listen 80;
        server_name _;

        set $routed_to       "unknown";
        set $upstream_target  "frontend.ecommerce-real.svc.cluster.local:3000";

        # ===========================================================
        # Health endpoint
        # ===========================================================
        location = /nginx-health {
            access_log off;
            content_by_lua_block {
                local routes = ngx.shared.attacker_routes
                local cjson  = require "cjson.safe"
                local keys   = routes:get_keys(0)
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    status        = "healthy",
                    service       = "traffic-router",
                    active_routes = #keys,
                }))
            }
        }

        # ===========================================================
        # Internal API: POST /internal/add-route
        # Body: {"attacker_ip":"<ip>","decoy_frontend_url":"<host:port>"}
        # ===========================================================
        location = /internal/add-route {
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 127.0.0.0/8;
            deny  all;

            content_by_lua_block {
                if ngx.req.get_method() ~= "POST" then
                    ngx.status = 405
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"method_not_allowed"}')
                    return
                end

                ngx.req.read_body()
                local cjson = require "cjson.safe"
                local body  = ngx.req.get_body_data()
                if not body then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"empty_body"}')
                    return
                end

                local data, parse_err = cjson.decode(body)
                if not data then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"invalid_json","detail":"' .. (parse_err or "parse error") .. '"}')
                    return
                end

                local ip  = data.attacker_ip
                local url = data.decoy_frontend_url
                if not ip or not url or ip == "" or url == "" then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"missing_fields","required":["attacker_ip","decoy_frontend_url"]}')
                    return
                end

                local routes = ngx.shared.attacker_routes
                local ok, err, forcible = routes:set(ip, url)
                if not ok then
                    ngx.status = 500
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"dict_set_failed","detail":"' .. (err or "unknown") .. '"}')
                    return
                end

                ngx.log(ngx.INFO, "[add-route] ", ip, " -> ", url)
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    status             = "ok",
                    attacker_ip        = ip,
                    decoy_frontend_url = url,
                    forcible           = forcible,
                }))
            }
        }

        # ===========================================================
        # Internal API: POST /internal/remove-route
        # Body: {"attacker_ip":"<ip>"}
        # ===========================================================
        location = /internal/remove-route {
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 127.0.0.0/8;
            deny  all;

            content_by_lua_block {
                if ngx.req.get_method() ~= "POST" then
                    ngx.status = 405
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"method_not_allowed"}')
                    return
                end

                ngx.req.read_body()
                local cjson = require "cjson.safe"
                local body  = ngx.req.get_body_data()
                if not body then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"empty_body"}')
                    return
                end

                local data, parse_err = cjson.decode(body)
                if not data or not data.attacker_ip or data.attacker_ip == "" then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"missing_attacker_ip"}')
                    return
                end

                ngx.shared.attacker_routes:delete(data.attacker_ip)
                ngx.log(ngx.INFO, "[remove-route] ", data.attacker_ip)
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"status":"ok","removed":"' .. data.attacker_ip .. '"}')
            }
        }

        # ===========================================================
        # Internal API: GET /internal/routes  (debug/inspection)
        # ===========================================================
        location = /internal/routes {
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 127.0.0.0/8;
            deny  all;

            content_by_lua_block {
                local cjson  = require "cjson.safe"
                local routes = ngx.shared.attacker_routes
                local keys   = routes:get_keys(1024)
                local result = {}
                for _, key in ipairs(keys) do
                    result[key] = routes:get(key)
                end
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({ routes = result, count = #keys }))
            }
        }

        # ===========================================================
        # Internal proxy to traffic-analyzer (subrequest target)
        # ===========================================================
        location = /_analyze {
            internal;
            proxy_pass         http://traffic-analyzer.deception-gateway.svc.cluster.local:8085/analyze;
            proxy_method       POST;
            proxy_set_header   Content-Type "application/json";
            proxy_connect_timeout 3s;
            proxy_read_timeout    5s;
            proxy_send_timeout    3s;
        }

        # ===========================================================
        # Main catch-all: rate limit → route check → analyze → proxy
        # ===========================================================
        location / {
            access_by_lua_block {
                local cjson     = require "cjson.safe"
                local routes    = ngx.shared.attacker_routes
                local rate_dict = ngx.shared.rate_limit
                local headers   = ngx.req.get_headers()
                local client_ip = ngx.var.remote_addr
                local attacker_hdr = headers["x-attacker-ip"]
                if attacker_hdr and attacker_hdr ~= "" then
                    client_ip = string.match(attacker_hdr, "^[^,%s]+") or attacker_hdr
                else
                    local xff = headers["x-forwarded-for"]
                    if xff and xff ~= "" then
                        local preferred = nil
                        for token in string.gmatch(xff, "([^,]+)") do
                            local ip = string.gsub(token, "^%s*(.-)%s*$", "%1")
                            if ip ~= "" then
                                if ip ~= ngx.var.remote_addr then
                                    preferred = ip
                                    break
                                end
                                if not preferred then
                                    preferred = ip
                                end
                            end
                        end
                        if preferred then
                            client_ip = preferred
                        end
                    end
                end

                -- =====================================================
                -- 1) Rate limiting — 30 req/s per IP (fixed window)
                -- =====================================================
                local rate_key = "rl:" .. client_ip
                local count, err = rate_dict:incr(rate_key, 1, 0, 1)
                if err then
                    ngx.log(ngx.ERR, "[rate-limit] incr error: ", err)
                elseif count and count > 30 then
                    ngx.log(ngx.WARN, "[rate-limit] ", client_ip, " exceeded (", count, "/30)")
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Retry-After"]  = "1"
                    ngx.status = 429
                    ngx.say('{"error":"rate_limit_exceeded","limit":30,"per":"second"}')
                    return ngx.exit(429)
                end

                -- =====================================================
                -- 2) Fast path — known attacker IP in shared dict
                -- =====================================================
                local decoy_url = routes:get(client_ip)
                if decoy_url then
                    ngx.var.routed_to      = "decoy:" .. decoy_url
                    ngx.var.upstream_target = decoy_url
                    return
                end

                -- =====================================================
                -- 3) Subrequest to traffic-analyzer
                -- =====================================================
                ngx.req.read_body()
                local raw_body     = ngx.req.get_body_data() or ""
                local body_snippet = string.sub(raw_body, 1, 2048)

                local h_subset = {}
                for _, name in ipairs({
                    "user-agent", "content-type", "referer",
                    "x-forwarded-for", "x-attacker-ip", "cookie", "authorization",
                    "accept", "host",
                }) do
                    if headers[name] then
                        h_subset[name] = headers[name]
                    end
                end

                local payload = cjson.encode({
                    method       = ngx.req.get_method(),
                    path         = ngx.var.request_uri,
                    headers      = h_subset,
                    body         = body_snippet,
                    source_ip    = client_ip,
                })

                local res = ngx.location.capture("/_analyze", {
                    method = ngx.HTTP_POST,
                    body   = payload,
                })

                -- Analyzer unreachable → default allow
                if not res or res.status ~= 200 then
                    ngx.var.routed_to = "real:frontend(analyzer-unavailable)"
                    return
                end

                local result = cjson.decode(res.body)
                if not result then
                    ngx.var.routed_to = "real:frontend(bad-analyzer-response)"
                    return
                end

                -- =====================================================
                -- 4) Route based on analyzer verdict
                -- =====================================================
                if result.action == "redirect_to_decoy" then
                    decoy_url = routes:get(client_ip)
                    if decoy_url then
                        ngx.var.routed_to      = "decoy:" .. decoy_url
                        ngx.var.upstream_target = decoy_url
                    else
                        ngx.var.routed_to = "real:frontend(no-decoy-route-yet)"
                    end
                else
                    ngx.var.routed_to = "real:frontend"
                end
            }

            proxy_pass            http://$upstream_target;
            proxy_http_version    1.1;
            proxy_set_header      Host              $host;
            proxy_set_header      X-Real-IP         $remote_addr;
            proxy_set_header      X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header      X-Forwarded-Proto $scheme;
            proxy_set_header      X-Original-URI    $request_uri;
            proxy_set_header      Connection        "";
            proxy_connect_timeout 5s;
            proxy_read_timeout    30s;
            proxy_send_timeout    10s;
            proxy_next_upstream       error timeout;
            proxy_next_upstream_tries 2;
        }
    }
}
