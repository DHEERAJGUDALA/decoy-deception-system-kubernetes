PHASE 4 - FILES CREATED
=======================

Go Source Code:
---------------
✓ services/sentinel/go.mod
✓ services/sentinel/go.sum                         (Auto-generated by go mod tidy)
✓ services/sentinel/cmd/main.go                    (470 lines)

Docker Configuration:
--------------------
✓ services/sentinel/Dockerfile                     (Multi-stage Alpine build)

Kubernetes Manifests:
--------------------
✓ deploy/k8s/sentinel-rbac.yaml                    (ServiceAccount + Role + RoleBinding)
✓ deploy/k8s/sentinel-configmap.yaml               (Detection rules and thresholds)
✓ deploy/k8s/sentinel.yaml                         (Deployment + Service)

Documentation:
-------------
✓ services/sentinel/USAGE.md                       (Usage guide with testing examples)
✓ PHASE4_SUMMARY.md                                (Phase 4 overview)
✓ PHASE4_EXAMPLES.md                               (Alert payload examples)
✓ ACTION_LOG.md                                    (Updated with Phase 4)
✓ PHASE4_FILES.txt                                 (This file)

Total Files: 12

Service Overview:
----------------
Name: sentinel
Type: Attack detection and alerting
Monitoring: Pod logs via Kubernetes SharedInformer
Binary Size: 37MB (stripped)
Image Size: ~40-45MB (Alpine + binary + ca-certs)

Attack Detection:
----------------
1. SQL Injection
   - Severity: Critical
   - Patterns: 4 regex rules (UNION SELECT, OR 1=1, SQL comments, etc.)

2. Path Traversal
   - Severity: High
   - Patterns: ../, ..\, URL-encoded variants

3. Rate Limit Exceeded
   - Severity: Medium
   - Threshold: >50 requests per minute per IP

4. Auth Failure Brute Force
   - Severity: High
   - Threshold: >3 auth failures in 1 minute

Alert Cooldown:
--------------
Duration: 5 minutes per IP
Purpose: Prevent alert spam from persistent attackers
Behavior: First attack → alert, subsequent → logged only

Alert Payload Structure:
-----------------------
{
  "timestamp": "ISO8601_UTC",
  "attack_type": "sql_injection|path_traversal|rate_limit_exceeded|auth_failure_brute_force",
  "source_ip": "attacker_ip",
  "evidence": "log_line_or_attack_summary",
  "severity": "critical|high|medium",
  "pod_name": "kubernetes_pod_name",
  "decoy_urls": ["url1", "url2", "url3"]
}

RBAC Permissions:
----------------
ServiceAccount: sentinel
Permissions:
  - pods: get, list, watch
  - pods/log: get, list

Configuration (ConfigMap):
-------------------------
controller_url: "http://controller:8080/api/alerts"
namespace: "default"
watch_labels: "app=frontend-api"
rate_limit_threshold: "50"
rate_limit_window: "1m"
auth_failure_limit: "3"
auth_failure_window: "1m"
cooldown_period: "5m"

Resource Allocation:
-------------------
Memory: 80Mi (request = limit)
CPU:    50m (request = limit)
QoS:    Guaranteed

Updated System Total:
--------------------
k3s:          ~800Mi
frontend-api:   80Mi
payment-svc:    40Mi
manager:        60Mi
sentinel:       80Mi
--------------------------
TOTAL:       ~1.06GB / 2.5GB budget ✓

Deployment Commands:
-------------------
# Build
cd services/sentinel
docker build -t sentinel:latest .

# For k3s
sudo nerdctl -n k8s.io build -t sentinel:latest .

# Deploy
kubectl apply -f deploy/k8s/sentinel-rbac.yaml
kubectl apply -f deploy/k8s/sentinel-configmap.yaml
kubectl apply -f deploy/k8s/sentinel.yaml

# Verify
kubectl get pods -l app=sentinel
kubectl logs -f -l app=sentinel

Testing Examples:
----------------
# SQLi detection
curl "http://NODE_IP:30000/api/products?id=1'%20UNION%20SELECT%20*%20FROM%20users--"
kubectl logs -l app=sentinel | grep sql_injection

# Path traversal detection
curl "http://NODE_IP:30000/api/file?path=..%2f..%2fetc%2fpasswd"
kubectl logs -l app=sentinel | grep path_traversal

# Rate limit detection
for i in {1..60}; do curl -s http://NODE_IP:30000/api/products > /dev/null & done
kubectl logs -l app=sentinel | grep rate_limit_exceeded

# Auth failure detection
for i in {1..5}; do
  curl -X POST http://NODE_IP:30000/api/login \
    -d '{"username":"admin","password":"wrong"}'
done
kubectl logs -l app=sentinel | grep auth_failure

Integration Flow:
----------------
Sentinel → Controller → Manager → Decoy Services

1. Sentinel detects attack in logs
2. Sentinel POSTs alert to Controller
3. Controller calls Manager /api/block_ip
4. Manager routes attacker to decoys (round-robin)
5. Attacker interacts with decoy environment

Key Features:
------------
✓ SharedInformer for efficient pod watching
✓ Real-time log streaming and parsing
✓ Pattern-based attack detection
✓ Configurable thresholds via ConfigMap
✓ 5-minute cooldown per attacker IP
✓ Structured JSON alert payloads
✓ RBAC with minimal permissions
✓ Non-blocking alert delivery

All requirements met ✓
Phase 4 complete ✓
