PHASE 3 - FILES CREATED
=======================

Go Source Code:
---------------
✓ services/manager/go.mod
✓ services/manager/cmd/main.go                     (270 lines)

Docker Configuration:
--------------------
✓ services/manager/Dockerfile                      (Multi-stage Alpine build)

Kubernetes Manifests:
--------------------
✓ deploy/k8s/manager.yaml                          (Deployment + NodePort Service)

Documentation:
-------------
✓ services/manager/USAGE.md                        (API usage guide with curl examples)
✓ PHASE3_SUMMARY.md                                (Phase 3 overview)
✓ PHASE3_EXAMPLES.md                               (Comprehensive test examples)
✓ ACTION_LOG.md                                    (Updated with Phase 3)
✓ verify-phase3.sh                                 (Verification script)
✓ PHASE3_FILES.txt                                 (This file)

Total Files: 10

Service Overview:
----------------
Name: manager
Type: Reverse proxy with IP blocking
Port: 8080 (internal), 30000 (NodePort external)
Binary Size: 6.2MB (stripped)
Image Size: ~11-15MB (Alpine + binary)

API Endpoints:
-------------
Management:
  - POST /api/block_ip          Block IP with 3 decoy URLs
  - POST /api/cleanup           Unblock IP
  - GET  /health                Health check + stats
  - GET  /api/stats             View blocked IPs

Reverse Proxy:
  - /*                          All other requests
                                → Legitimate service (normal IPs)
                                → Decoy services (blocked IPs, round-robin)

Key Features:
------------
✓ In-memory IP blocking (no database)
✓ Round-robin routing across exactly 3 decoy URLs
✓ Thread-safe concurrent access (sync.RWMutex)
✓ Source IP detection (X-Forwarded-For, X-Real-IP, RemoteAddr)
✓ Structured JSON logging
✓ NodePort 30000 for external access
✓ No K8s Services used for decoy routing (direct URLs)

Round-Robin Logic:
-----------------
selectedURL = decoyURLs[counter % len(decoyURLs)]
counter++ after each request

Request 1 → decoy_urls[0]
Request 2 → decoy_urls[1]
Request 3 → decoy_urls[2]
Request 4 → decoy_urls[0] (cycles)

Resource Allocation:
-------------------
Memory: 60Mi (request = limit)
CPU:    50m (request = limit)
QoS:    Guaranteed

Updated System Total:
--------------------
k3s:          ~800Mi
frontend-api:   80Mi
payment-svc:    40Mi
manager:        60Mi
--------------------------
TOTAL:        ~980Mi / 2.5GB budget ✓

Configuration:
-------------
Environment Variables:
  PORT=8080                    # Service port
  LEGITIMATE_SERVICE_URL=...   # Target for normal traffic

Deployment Commands:
-------------------
# Build
cd services/manager
docker build -t manager:latest .

# For k3s
sudo nerdctl -n k8s.io build -t manager:latest .

# Deploy
kubectl apply -f deploy/k8s/manager.yaml

# Verify
kubectl get pods -l app=manager
kubectl get svc manager

# Access
NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
curl http://$NODE_IP:30000/health

Usage Examples:
--------------
# Block IP
curl -X POST http://$NODE_IP:30000/api/block_ip \
  -H "Content-Type: application/json" \
  -d '{
    "source_ip": "192.168.1.100",
    "decoy_urls": [
      "http://decoy-1:8080",
      "http://decoy-2:8080",
      "http://decoy-3:8080"
    ]
  }'

# Cleanup IP
curl -X POST http://$NODE_IP:30000/api/cleanup \
  -H "Content-Type: application/json" \
  -d '{"source_ip": "192.168.1.100"}'

# Test routing (simulate blocked IP)
curl -H "X-Forwarded-For: 192.168.1.100" \
  http://$NODE_IP:30000/api/products

Integration Points:
------------------
→ Sentinel (Phase 4): Calls /api/block_ip to redirect attackers
→ Controller (Phase 5): Provides decoy URLs for blocking
→ Reporter (Phase 6): Analyzes decoy traffic patterns

All requirements met ✓
Phase 3 complete ✓
